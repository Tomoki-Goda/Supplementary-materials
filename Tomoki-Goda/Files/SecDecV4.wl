(* ::Package:: *)

SecDecTest=True;



(* ::Section:: *)
(*Begin*)


(*******************************************************************************
 * 
 *
 *  Sector decomposition package
 *
 *
 ******************************************************************************)

BeginPackage["SecDecV4`", {"Global`","ExpandPowerV2`"}];

PrepareIntegral::usage = ""
Process::usage = ""
SecDec::usage = ""
SecDec2::usage = ""
Types::usage = ""
types::usage = ""
types2::usage = ""
types3::usage = ""
dW::usage = ""
ProcessJacobian::usage = ""
ExtractMonomial::usage = ""
spToc::usage = ""
TriangleSplit::usage = ""
SplitPattern::usage = ""
SectorDecompositionLC1S::usage = ""
SectorDecompositionAE1HR::usage = ""
SectorDecompositionAE1S::usage = ""
SectorDecomposition12::usage = ""
(*J1::usage = ""
J2::usage = ""*)
GenerateReplSin::usage = ""
(*NonLinTrans::usage = ""
DeterminSign::usage = ""*)

NonLinearTransformation::usage="";


Begin["`Private`"];




Protect[zeta]


SplitPattern=Import["splitpattern"<>ToString[numberofparticles]<>".m"]


(*If[numberofparticles==3,SplitPattern=Import["./splitpattern3.m"]]*)(* File should be generated by GenerateSecDec.wls*)


(*If[numberofparticles==2,SplitPattern=Import["./splitpattern2.m"]]
If[numberofparticles\[Equal]1,SplitPattern=Import["./splitpattern1.m"]]*)


(* ::Section::Closed:: *)
(*Miscellaneous*)


(* ::Subsection::Closed:: *)
(*Miscellaneous*)


SectorDecomposition::leftangles="Angles `1` is/are not replaced";


thirdAE[a1_,a2_,a3_]:=-(-1+Cos[a1] Cos[a2]+Cos[a3] Sin[a1] Sin[a2]);
(*thirdLC[a1_,a2_,a3_]:=a1/(2 a2)+ a2/(2 a1)- Cos[a3];*)
thirdLC[a1_,a2_,a3_]:=limli[a1](liTli[a2])^2/(2 limli[a2])+ limli[a2](liTli[a1])^2/(2 limli[a1])-(liTli[a1]liTli[a2]) Cos[a3];


NonLinTrans[p1_,p2_,ang_,phase_:0]:=Module[{repllist, valcos, valsin,l23},
If[IntersectingQ[li,{p1,p2}],
l23[a3_]:=Block[{}, thirdLC[p1,p2,a3]],
l23[a3_]:=Block[{}, thirdAE[p1,p2,a3]]
];
repllist=Reduce[(l23[Pi+phase]l23[0+phase])/(l23[Pi+phase]-zeta (l23[Pi+phase]-l23[0+phase]))==l23[ang+phase],Cos[ang]];
valcos = Cases[repllist,Cos[ang]==repfromcos_:>(Cos[ang]->repfromcos),-1];

If[Length[valcos]>1,Print["Error"];Abort[]];

 valsin = {Sin[ang]->Simplify[Sqrt[1-Cos[ang]^2]/.valcos], 
            Csc[ang]->1/Simplify[Sqrt[1-Cos[ang]^2]/.valcos]};
  Return[Join[valcos, valsin]];

]


Options[GenerateReplSin]={Usesr->True,Usey->UseY}
GenerateReplSin[list_List,OptionsPattern[]]:=Module[{i,assoc,repl(*,fac=OptionValue[factor],pha=OptionValue[phase]*)},
repl=MapThread[{Rule[Cos[#1],(1-2#2)],
Rule[Sin[#1],(2 Sqrt[#2]Sqrt[1-#2])],
Rule[Csc[#1],1/(2  Sqrt[#2]Sqrt[1-#2])],
Rule[Cos[#1/2],Sqrt[1-#2]],
Rule[Sin[#1/2],Sqrt[#2]],
Rule[Csc[#1/2],1/(Sqrt[#2])],
Rule[Cos[2 #1],(2 (1-2 #2 )^2 )-1]
}&,list//Transpose]//Flatten;
If[VerboseFunctions>=3,Print[repl]];
Return[repl]
]


 SDFinalProcessing[in_,simplify_:False]:=
 Module[{sectors},
 Print["final processing."];
  If[!FreeQ[in,Abs],Print[Style["Abs[] present",Red]];sectors=sectors//BreakAbs];
  If[!FreeQ[in,Alternatives@@angles],
  Print[Style[ToString[Union[Cases[in,Alternatives[Cos,Sin,Csc,Sec,Tan,Cot][_],-1]]],Green]];
  Print[Style[ToString[Union[Cases[in,Alternatives@@angles,-1]]],Green]]
  (*;Abort[]*)];
  sectors= in//ExpandPower;
  
  If[simplify,sectors=Simplify[sectors]];
  
  sectors = sectors //.J[arg1_]^pow1_. J[arg2_]^pow2_.:> J[arg1^pow1 arg2^pow2];
  sectors = sectors /.J[fac_. ME[sc__]]:>J[fac]ME[sc]/.J[fac_. ME0[sc__]]:>J[fac]ME0[sc];
  sectors = sectors /.HeavisideTheta[arg_] :> HeavisideTheta[Together[arg]];
  sectors = sectors/.Power[arg_,pow_] :> Power[Together[arg],pow];
  sectors = sectors /.J[arg1_]:> J[arg1 //Simplify[#,TransformationFunctions->{Expand,Factor}]&];
  sectors= sectors/.{Sqrt[a_]:>Simplify[Sqrt[a]],Power[a_,pow:1/2|-1/2|3/2|-3/2]:>Simplify[Power[a,pow]]};
  Return[sectors]
  ];



DeterminSign[jacnonlin_,ReplNonLin_]:=Module[{varrep,jacsign,jac,expr},

varrep=jacnonlin/.Abs[ar_]:>Sqrt[(ar)^2]//Variables;
jacsign=jacnonlin/.Map[#->RandomReal[{0.1,0.9}]&,varrep];
jacsign=Simplify[jacsign>0];

expr=ReplNonLin[[1,2]];
expr={expr/.{x7->0,zeta->0},expr/.{x7->1,zeta->1}}//ExpandPower//Simplify;
If[expr==={-1,1}&&(jacsign===True),jacsign=1,
 If[expr==={1,-1}&&(jacsign===False),jacsign=-1;Print[Style["negative jacobian",Cyan]],Print["Error", expr,jacsign]
 ];
];

jac=jacsign jacnonlin;
Return[jac]
];


NonLinearTransformation[var1_,var2_,var3_,phase_]:=Module[{ReplNonLin, jacnonlin },
ReplNonLin = NonLinTrans[var1,var2,var3,phase];
jacnonlin = (ReplNonLin[[1,2]])//ExpandPower;
jacnonlin =Simplify[D[jacnonlin,zeta]/Sin[var3]//.ReplNonLin];
(*Print[ReplNonLin,jacnonlin];*)
jacnonlin=DeterminSign[jacnonlin,ReplNonLin];
ReplNonLin={jacnonlin,ReplNonLin}//ExpandPower//Simplify;
Return[ReplNonLin];
]


(* ::Subsection::Closed:: *)
(*splitting*)


Options[TriangleSplit]={Jacobian->True,simplify->False};
TriangleSplit[list_List,list2_List, OptionsPattern[]]:=Module[{out={},res,jac,Fvar,Ivar,F,list22,i},
If[Length[list]=!=Length[list2],Print["Error"];Return[list]];
(*If[VerboseFunctions>=2,Print["splitting"]];*)
For[i=1,i<=Length[list2],i++,
If[list2[[i]]=={},res={list[[i]]},
list22={
	{list2[[i]][[1]]->list2[[i]][[1]] list2[[i]][[2]]},
	{list2[[i]][[2]]->list2[[i]][[1]] list2[[i]][[2]]}};

(*Print[list22//TableForm];*)
res=Map[list[[i]]/.#&,list22];

If[OptionValue[Jacobian],
jac=Reverse[list2[[i]]];
res=MapThread[J[#1] #2&,{jac,res}]
(*Print[{jac,list22}]*)
]
];
out=Join[out,res];
];
If[OptionValue[simplify],out=Simplify[out//ExpandPower]];
Return[out]
]


Options[HalfSplit]={Jacobian->True,simplify->False};
HalfSplit[list_List,list2_List,OptionsPattern[]]:=Module[{out={},res,jac,list22,i},
If[Length[list]=!=Length[list2],Print["Error"]];
(*If[VerboseFunctions>=2,Print["splitting"]];*)
For[i=1,i<=Length[list2],i++,
If[list2[[i]]===Null,res={list[[i]]},
list22={{list2[[i]]->list2[[i]] /2},
		{list2[[i]]->(1-list2[[i]]/2)}};

(*Print[list22//TableForm];*)
res=Map[list[[i]]/.#&,list22];
If[OptionValue[Jacobian],
jac={1/2,1/2};
res=MapThread[J[#1] #2&,{jac,res}]
(*Print[{jac,list22}]*)
]
];
out=Join[out,res];
];
If[OptionValue[simplify],out=Simplify[out//ExpandPower]];
(*If[OptionValue[simplify],out=ExpandPower[Simplify[out/.Reply/.sr[arg_]:>Sqrt[arg]//ExpandPower]]];*)
Return[out]
]


Options[SplitAndAssignVariables]={Jacobian->True};
SplitAndAssignVariables[exp_,oldvar_List,newvar_List,inf_,OptionsPattern[]]:=Module[{rep1,rep2,jac1,jac2,res},
rep1={{oldvar[[1]]->newvar[[1]] oldvar[[2]]},
           {oldvar[[2]]->newvar[[2]] oldvar[[1]]}};
(*rep2={If[MemberQ[inf,oldvar[[2]]],oldvar[[2]]->newvar[[2]]/assocxy[newvar[[2]]],oldvar[[2]]->newvar[[2]]],
           If[MemberQ[inf,oldvar[[1]]],oldvar[[1]]->newvar[[1]]/assocxy[newvar[[1]]],oldvar[[1]]->newvar[[1]]]};*)
rep2={If[MemberQ[inf,oldvar[[2]]],oldvar[[2]]->newvar[[2]]/(1-newvar[[2]]),oldvar[[2]]->newvar[[2]]],
           If[MemberQ[inf,oldvar[[1]]],oldvar[[1]]->newvar[[1]]/(1-newvar[[1]]),oldvar[[1]]->newvar[[1]]]};


jac1={oldvar[[2]],oldvar[[1]]};
jac2={If[MemberQ[inf,oldvar[[2]]],(1-newvar[[2]])^(-2),1],
           If[MemberQ[inf,oldvar[[1]]],(1-newvar[[1]])^(-2),1]
};

(*Print[rep1];
Print[rep2];*)

If[OptionValue[Jacobian]===True,
(*Print[{rep1,jac1,rep2,jac2}];*)
res=MapThread[J[ #4](J[#2](exp/.#1)/.#3)&,{rep1,jac1,rep2,jac2}],
res=MapThread[((exp/.#1)/.#2)&,{rep1,rep2}]];
Return[res]
];



(* ::Subsection::Closed:: *)
(*Type sorting*)


Types[name_,inputraw_]:=Module[{pos},

pos=types[#]&/@inputraw;
pos=Position[pos,name];
Return[Flatten[pos]]];



types[inputraw_]:=Module[{res},
If[numberofparticles==1,
res="nlo"
];
If[numberofparticles==2,
res=types2[inputraw]
];
If[numberofparticles==3,
res=types3[inputraw]
];
Return[res];
];





types2[inputraw_]:=Module[{secdec},
If[Length[inputraw[[3]]]==2,
secdec="SectorDecomposition12",

If[Length[inputraw[[1]]]==1,
 If[Length[inputraw[[2]]]==1,
 secdec="SectorDecompositionAE1HR",
 secdec="SectorDecompositionLC1S"],
 If[Length[inputraw[[1]]]==0&&Length[inputraw[[2]]]==1,
 secdec="SectorDecompositionAE1S",
 Print["Error, unknown type"];
 ];
 ];
 ];
 Return[secdec];
 ];


types3[inputraw_]:=Module[{print="none",secdec,phi},

If[Length[inputraw[[3]]]==3,
secdec="SectorDecomposition123";
];
If[Length[inputraw[[3]]]==2,
If[Length[inputraw[[1]]]==2&&Length[inputraw[[2]]]==0,
secdec="SectorDecompositionLC3";
];
If[Length[inputraw[[1]]]==2&&Length[inputraw[[2]]]==1,
secdec="SectorDecompositionLC3SR";

];
If[Length[inputraw[[2]]]==2&&Length[inputraw[[1]]]==0,
secdec="SectorDecompositionAE3";
];
If[Length[inputraw[[2]]]==2&&Length[inputraw[[1]]]==1,
secdec="SectorDecompositionAE3SH";
];
If[Length[inputraw[[1]]]==1&&Length[inputraw[[2]]]==0,
secdec="SectorDecompositionLC2";
];
If[Length[inputraw[[1]]]==0&&Length[inputraw[[2]]]==1,
secdec="SectorDecompositionAE2";
];
];
If[Length[inputraw[[3]]]==1,Print["Input Error"]];
If[Length[inputraw[[3]]]==0,secdec="SectorDecompositionN1N2"];
Return[secdec];

];


(* ::Section::Closed:: *)
(*Prepare and process*)


(* ::Subsection::Closed:: *)
(*Prepare*)


AssociateAngleMom[ReplMom_,listofangles_]:=Module[{takenang,takenpos,assocangmom,associatedangles,removed,pos,i},
takenpos={};
takenang={};
assocangmom={};
For[i=1,i<=numberofparticles,i++,
associatedangles=li/.ReplMom;
associatedangles=DeleteDuplicates[Cases[#,Alternatives@@Flatten[listofangles],-1]]&/@associatedangles;
removed=DeleteCases[associatedangles,Alternatives@@Flatten[{takenang,listofangles[[i]]}],{2}];
(*Print[removed];*)
pos=Position[removed,{}];
pos=Complement[pos,takenpos];
(*Print[pos,takenpos];*)
takenpos=Join[takenpos,pos];
takenang=Flatten[{takenang,listofangles[[i]]}];
AppendTo[assocangmom,{li[[First[Flatten[pos]]]],Sort[listofangles[[i]]]}];
];
Return[assocangmom]
]


GroupAngles[ReplMom_,Angles_:{"th","ch","ph"}]:=Module[{ang,angname,angs},
ang=ReplMom//Cases[#,Sin[a_]|Cos[a_]:>ToString[a],-1]&//DeleteDuplicates;
angname=Map[StringTake[ToString[#],2]&,ang]//DeleteDuplicates;
angs=Map[Join@@StringCases[ang,#~~_]&,Angles];
(*angs=SortBy[angs,Length];*)
angs=Take[angs,numberofparticles];
angs=Map[SortBy[#,ToExpression[StringDrop[#,2]]&]&,angs];
angs=Map[ToExpression,angs,{2}];
Return[angs]
]


SurfaceIntegral::message="ordering is wrong";


SurfaceIntegral[ReplMom_,Angles_:{"th","ch","ph"}]:=Module[{surface,angs,Surface,i,assocangmom,dim,type,LC,AE},
(*************make a list of angle parameters grouped by the names \[Phi], \[Chi],... ***********************)

(****************************************************)
angs=GroupAngles[ReplMom,Angles];
(*Print[angs];*)
(*determin dimensions...sort of...*)
assocangmom=AssociateAngleMom[ReplMom,angs];
dim=MapThread[DeleteDuplicates[Cases[#1/.ReplMom,Alternatives@@Join[#2,lim],-1]]&,Transpose[assocangmom]];
(*Print[dim];*)
If[Not[And@@MapThread[SubsetQ[#1,#2]&,{dim,angs}]],Message[SurfaceIntegral::message];Print[{angs,dim}]];



For[i=1,i<=Length[angs],i++,
angs=ReplacePart[angs,i->Prepend[angs[[i]],If[i<=2,S[d-(2+i)],dW[d-4,Take[angs[[i]],2-numberofparticles]]]]];
];(*Prepend Trivial surface integral*)

Surface={};
For[i=1,i<=numberofparticles,i++,
If[FreeQ[dim[[i]],Alternatives@@lim],type=AE,type=LC];
surface=1;
surface*=angs[[i,1]];(*Sdim or dW*)

If[Length[angs[[i]]]>=2,(*if there are/is nontrivial angles*)
	If[type===LC,
		surface*=Product[Sin[angs[[i,j]]]^(d-(j+2)),{j,2,Min[2,Length[angs[[i]]]]}],
		If[type===AE,
			surface*=Product[Sin[angs[[i,j]]]^(d-(j+1)),{j,2,Min[3,Length[angs[[i]]]]}],
			Print["Error"]
		];
	];
];

AppendTo[Surface,surface];
];


Return[Surface]
];





PrepareIntegral[me_, ReplMom_] := Module[{order,sps,replsps,int, elements,mom, ki,angles,assocangmom,
      ReplFuncArgSum = {
      sp[arg1_,arg2_+arg3_]:>sp[arg1,arg2]+sp[arg1,arg3],
      spT[arg1_,arg2_+arg3_]:>spT[arg1,arg2]+spT[arg1,arg3],
      sp[-arg1_,arg2_]:>-sp[arg1,arg2]},
      pos, 
      ReplEn = {l10->(l1m+l1p)/2, l20->(l2m+l2p)/2, l30->(l3m+l3p)/2},
      k1, k2, k3,  k1m, k2m, k3m, k1p, k2p, k3p, k1T, k2T, k3T, k10, k20, k30,
      k1d, k2d, k3d,
      km,k0,kT,kd,kp,LCAE,repl,Surface,i,repld={},
      jacsin
      },
      PrepareIntegral::spleft="sp[] left. replaced with ReplMom for now.";

  (* Order momenta *)
   elements=Count[#, 0,1] & /@ (li //. ReplMom);
   order=Transpose[{li,elements}];
   order=SortBy[order,Last];
   mom=order[[All,1]];
   (*Print[mom];*)
(*  elements = (2 - Count[#, 0] & /@ ({l1, l2, l3} //. ReplMom)) + 1;
  pos = Position[elements, #] & /@ {1, 2, 3} // Flatten;
  mom = {l1, l2, l3}[[pos]];*)
  ki = mom;

(*******Instead of using replacement for vectors, here defines replacements for sp[]. 
In this way easier to simplify in some cases********)
sps=Subsets[Join[{p},li,{n1,n2}],{2}];
(*sps=Permutations[{p,l1,l2,l3,n1,n2,p,l1,l2,l3,n1,n2},{2}];*)
sps=sp@@@sps//DeleteDuplicates;
(*sps=sps/. p -> pm/2 n1/. sp[n2,p] -> pm;*)
replsps=sps/.ReplMom/.Replsp//Simplify;
replsps=MapThread[#1->#2&,{sps,replsps}];
(*Print[replsps];*)
 (*Define Variables*)
    km = ToExpression[ToString[#]<>"m"]&/@ki;
    kp= ToExpression[ToString[#]<>"p"]&/@ki;
    kT= ToExpression[ToString[#]<>"T"]&/@ki; 
    k0 = ToExpression[ToString[#]<>"0"]&/@ki;
    kd= ToExpression[ToString[#]<>"d"]&/@ki;

(*Start*)
    int = measureorig me  (*/. p -> pm/2 n1*) //.ReplFuncArgSum (*/.sp[n2,p] -> pm*);
(*T/F parametrized in LC or AE*)
LCAE=FreeQ[#,Alternatives@@lim]&/@(mom/.ReplMom);

(*Solve Delta Jacobian from delta & change of coordinates*)
repl={};
For[i=1,i<=Length[LCAE],i++,
If[LCAE[[i]],
AppendTo[repld,delta[sp[mom[[i]],mom[[i]]]]->1/(2 k0[[i]]) delta[kd[[i]]-k0[[i]]]];
AppendTo[repl,kd[[i]]->k0[[i]]],

AppendTo[repld,delta[sp[mom[[i]],mom[[i]]]]->1/(2 km[[i]]) delta[kp[[i]]-kT[[i]]^2/km[[i]] ]];
AppendTo[repl,kp[[i]]->kT[[i]]^2/km[[i]] ];
AppendTo[repl,k0[[i]]->(km[[i]]+kp[[i]])/2]
]];


(*integrating surface*)
For[i=1,i<=Length[LCAE],i++,
If[LCAE[[i]],
AppendTo[repld,d[d,mom[[i]]]->kd[[i]]^(d-2) ];
,
AppendTo[repld,d[d,mom[[i]]]->kT[[i]]^(d-3)];
]];

Surface=SurfaceIntegral[ReplMom];
(*jacsin=Map[Times@@Map[Sin[#]^-1&,DeleteDuplicates[Cases[#,Alternatives@@{th1,ch1,ch2,ph1,ph2,ph3},-1]]] &,Surface];
Surface=Inner[Times,jacsin,Surface,List];*)(* if we consider inegrating over Cos[th] not th*)
angles=DeleteDuplicates[Cases[#,Alternatives@@{th1,ch1,ch2,ph1,ph2,ph3},-1]]&/@Surface;
angles=Sort/@angles;

assocangmom=AssociateAngleMom[ReplMom,GroupAngles[ReplMom]];
assocangmom=Map[Rule@@Reverse[#]&,assocangmom];
assocangmom=Association[assocangmom];
(*Print[angles,assocangmom];*)
Surface=MapThread[Rule[d[d,assocangmom[#1]],ReplaceAll[ d[d,assocangmom[#1]]#2,repld]]&,{angles,Surface}];

repld=Normal[KeyDrop[Association[repld],Map[d[d,#]&,li]]];
(*Print[Surface];*)

repld=Join[repld,Surface];

int = int/.repld//.replsps//.repl/.delta[0]->1;
int = int /.d->4-2 ep;
 If[!FreeQ[int,sp|spT],Message[PrepareIntegral::spleft];Print[Cases[int,sp[__],-1]];
    int=int//.ReplMom/.Replsp];

Return[Simplify[int, Trig ->True]];
]


(* ::Subsection::Closed:: *)
(*Process*)


(****************************************************************************** 
 *
 * Substitute momenta, perform on-shell delta functions, simplify measures
 *
 ******************************************************************************)
Process[integral_, km_] := Module[{tmp, delarg, delsol, deljac(*, phi*)},
If[integral===0,Return[integral]];
 (* phi = First[Cases[integral,Alternatives@@angles,-1]];*)
  tmp = integral //.{J[arg_]:>arg, prop[arg_]:>arg};

  tmp=tmp/.delta[a_]:>delta[Collect[a,km]];
  delarg = Cases[tmp, delta[arg_]:>arg,-1];
  If[delarg==={},Print[delarg,Cases[tmp, delta[arg_],{0,Infinity}]]];
  delarg = delarg //Last;
  (*Print[delarg];*)
  delsol = Solve[delarg == 0, km]//Flatten;
 (* Print[delsol //ExpandPower//Simplify];*)
  deljac = D[delarg, km];
 (*Print[deljac];*)

  tmp = 1/deljac tmp/.delsol;
  tmp = tmp/.delta[arg_] :>delta[Simplify[ExpandPower[arg]]]/. delta[0] -> 1;
  
 Process::scaling = "argument of delta is not reduced to zero.";
 If[!FreeQ[(tmp //. delta[0] -> 1),delta],
      Message[Process::scaling];Print[tmp];Print[Cases[tmp,delta|delta[_],-1]]; Abort[]
   ];

  Return[ HeavisideTheta[km/.delsol] tmp/.d->4-2 ep /. delta[0] -> 1 /. pm->1];
]



ExtractMonomial::monoialremaining="monomials may not be not fully taken out";
ExtractMonomial::series="series expansion used";
ExtractMonomial[expr_,var_:activevariables]:=Module[{out,mono,rem,limit,zeropos,servar,ser,sermon},
(*Print[var];
Print[activevariables];*)
out=expr//.{
Power[(x:(Alternatives@@var )) fac_,pow_]:>Power[x,pow]Power[fac,pow],Power[(x:(Alternatives@@Map[Sqrt,var])) fac_,pow_]:>Power[x,pow]Power[fac,pow],Power[(x:(Alternatives@@Map[Power[#,p_]&,var])) fac_.,pow_]:>Power[x,pow]Power[fac,pow],
Power[a_,b_]:>Power[Factor[a],b],
Power[Power[x:Alternatives@@var,pow_] fac_.,pow2_]:>Power[(x ),pow pow2]Power[fac,pow2]
};
out=out/.Power[Power[x:Alternatives@@var,pow_] fac_.,pow2_]:>Power[x ,pow pow2]Power[fac,pow2];
out=out//Cancel//FactorList;
mono=Times@@Power@@@Cases[out,{Alternatives@@Flatten[Map[{#^p_.,Sqrt[#]}&,var]],p2_}];
rem=Times@@Power@@@DeleteCases[out,{Alternatives@@Flatten[Map[{#^p_.,Sqrt[#]}&,var]],p2_}];
(*Print[(rem)];*)
(*limit=(Map[Simplify[rem/.#->0,TimeConstraint\[Rule]0.1]&,var]);*)
(*If[rem===0,Return[{1,0}]];*)
If[rem===0,Return[{0,0}]];
limit=(Map[rem/.#->0&,var]);
If[FreeQ[limit,0,1],
Return[{mono,rem}],
(********Series*******************)
Message[ExtractMonomial::series];
(*Print[rem];*)
zeropos=Position[limit,0,1];
servar=Map[activevariables[[Sequence@@#]]&,zeropos];
(*Print[servar];*)
ser=Normal[Series[rem,Sequence@@Map[{#,0,1}&,servar]]];
ser=Fold[Collect[#1,#2,Simplify[#,TimeConstraint->1]&]&,ser,servar];
sermon=ExtractMonomial[ser];
sermon=First[sermon];
(*Print[sermon];*)
mono*=sermon;
rem/=sermon;

limit=Map[Simplify[Limit[rem,{#->0},Direction->"FromAbove"],TimeConstraint->1]&,servar];
If[FreeQ[limit,0,1],
Message[ExtractMonomial::monoialremaining];Print[rem];Abort[],

Return[{mono,rem}]
];
];

(*If[(rem/.Map[#->0&,var])=!=0,
Return[{mono,rem}],Message[ExtractMonomial::monoialremaining](*;Print[rem]*);Return[{mono,rem}]
];*)
];


ProcessJacobian[processed_]:=Module[{me,jac1,mono,monojac,rem1,jac2,regjac,regmono,rem2,jacall,reg},
(***************** ME[__] *********************)
(*Print["ME"];*)
me=First[Cases[processed,ME[a__],-1]]//ExpandPower//Cancel[#,Trig->True]&;
(**********************************************)

(************************Jacobian coming from secdec etc************************)
(*Print["J1"];*)
jac1=processed/.ME[__]->1/.{TEST[_][_]->1}/.HeavisideTheta[a_]:>Simplify[HeavisideTheta[a]]//ExpandPower//Cancel[#,Trig->True]&;
{mono,rem1}=ExtractMonomial[jac1];
(*Print[rem1/.{x1\[Rule]0,x2\[Rule]0,x3\[Rule]0,x4\[Rule]0}//Simplify];*)
(****************************************************************************)

(**************************Part of jacobians with ep ap*********************)

jac2=Cases[processed,TEST[a_][b_]:>b,-1];
(*Print["1: ",jac2];*)
jac2=jac2//ExpandPower[#,exclusions->{ep,ap}]&;
(*Print["2: ",jac2];*)
jac2=jac2//Cancel[#,Trig->True]&;
(*Print["3: ",jac2];*)
jac2=Times@@jac2;
{regmono,rem2}=ExtractMonomial[jac2];

reg=regmono/(regmono/.{ep->0,ap->0});
PrintTemporary[reg];
regmono=regmono/.{ep->0,ap->0};
(*Print[rem2];
Print[rem2/.{x1\[Rule]0,x2\[Rule]0,x3\[Rule]0,x4\[Rule]0}//Simplify];*)
(*****************************************************************************)
mono=regmono mono;
jacall=J1[rem1]J2[ rem2];
jacall/.Map[#->0&,activevariables]//Simplify;
Return[{reg/(Times@@activevariables),Times@@activevariables mono jacall me}];
]


spToc[processed_,variables_:variables]:=Module[{spexpr,mon,cexpr,replsp,replc},
spexpr=Cases[processed,ME[a__]:>a,-1];
{mon,cexpr}=Transpose[Map[ExtractMonomial,spexpr]];
replsp=MapThread[#1->#2 ReplaceAll[#1,{sp->c[0],spT->cT[0]}]&,{variables,mon}];
replc=MapThread[ReplaceAll[#1,{sp->c[0],spT->cT[0]}]->#2&,{variables,cexpr}];
replc/.Map[#->0&,activevariables];
Return[{replsp,replc}]
];


spToc::monomial="monomial is not properly removed or secdecis insufficient";


(* ::Section::Closed:: *)
(*SecDec*)


(* ::Subsection::Closed:: *)
(*123*)


SectorDecomposition123[integral_, k1_, k2_, phi_,simplify_] := Module[{
ReplSin =GenerateReplSin[{{th1,x6},{ch1,x1},{ph1,x2}, {ch2,x8}}] ,k10,k20,k30,ReplNonLin,jacnonlin,res,sectors, 
k3 = Last[Complement[{l1,l2,l3},{k1,k2}]] ,variables},

    (* Relevant integration variables *)
  k10 = ToExpression[ToString[k1]<>"0"];
  k20 = ToExpression[ToString[k2]<>"0"];
  k30 = ToExpression[ToString[k3]<>"0"];
  
  (* Put all but props to J function *)
  
 res = J[integral];
 res = J[2/Sin[th1] 2/Sin[ch1] 2/Sin[ph1] 2/Sin[ch2]] res //.ReplSin;
 res=res/.ME[a__]:>ME[Sequence@@Simplify[{a}]]/.J[a_]:>J[Simplify[a]]//ExpandPower;

 
   (*****************************************************************************)
  ReplNonLin = NonLinearTransformation[ch1, ph1, phi, Pi]/.zeta->x7; 
  ReplNonLin = ReplNonLin//.ReplSin//ExpandPower;
  ReplNonLin = TriangleSplit[{ReplNonLin},{{x1,x2}},Jacobian->False];(*do splitting in advance to remove Abs[]*)
  ReplNonLin=ReplNonLin//Simplify//ExpandPower;
  ReplNonLin=ReplNonLin/.Abs[a_]:>Sqrt[a^2]//ExpandPower;
  (*Print[ReplNonLin];*)
  res=res//ExpandPower;
  
  sectors=TriangleSplit[{res},{{x1,x2}}]/.Abs[a_]:>Sqrt[a^2]//ExpandPower;
   
  sectors=Table[J[ReplNonLin[[i,1]]] (sectors[[i]]//.ReplNonLin[[i,2]]),{i,Length[sectors]}];(*Now apply NonLinTrans*)
  

   If[Cases[sectors,th1|ch1|ch2|ph1|ph2,-1]=!={},
  Message[SectorDecomposition::leftangles,Cases[sectors,Cos[_]|Sin[_]|Csc[_]|Tan[_],-1]//DeleteDuplicates]
  ];
   (****************************************************************************)
  
  If[simplify===True,(*Print["simplify"];*)
  sectors=sectors//ExpandPower;
  sectors=sectors//Simplify]; 
  
 (*Print[sectors];*)
   (****************************************************************************)
   sectors=HalfSplit[sectors,{x1,x2}]/.Abs[a_]:>Simplify[Abs[a]]; 
   (****************************************************************************)
 If[simplify===True,(*Print["simplify"];*)
  sectors=sectors//ExpandPower;
  sectors=sectors//Simplify];
  (****************************************************************************)
 sectors = SplitAndAssignVariables[sectors,{k10,k20},{x3,x4},{k10,k20}]//Flatten;
  (****************************************************************************)
  If[simplify===True,(*Print["simplify"];*)
  sectors=sectors//ExpandPower;
  sectors=sectors//Simplify];        
            
(*Print [{k1,k2}];*)
    
   (*sectors=Append123[sectors,k1,k2,simplify];*)

  (*sectors=(HeavisideTheta[k30] #)&/@sectors; *)
  sectors = sectors/.{k30 -> x5};
  Return[sectors]
];


(* ::Subsection::Closed:: *)
(*LC3*)


SectorDecompositionLC3[integral_, k1_, k2_, phi_, simplify_] := Module[{

  ReplSin = GenerateReplSin[{{ph1,x8}}],
  ReplNonLin, jacnonlin, res, k1m, k2m, k3m, k1T, k2T, k3T, sectors, 
  k3 = Last[Complement[{l1,l2,l3},{k1,k2}]]
  },

  (*Print[{k1,k2,phi}];*)
  (* Relevant integration variables *)
  k1m = ToExpression[ToString[k1]<>"m"];
  k2m = ToExpression[ToString[k2]<>"m"];
  k3m = ToExpression[ToString[k3]<>"m"];
  k1T = ToExpression[ToString[k1]<>"T"];
  k2T = ToExpression[ToString[k2]<>"T"];
  k3T = ToExpression[ToString[k3]<>"T"];
  
  (* Put all but props to J function *)
  res = J[integral];
  res= J[2/Sin[ph1]]res//.ReplSin;
  res = J[k1T k2T] HeavisideTheta[1-k1m] HeavisideTheta[1-k2m] res /.{k1m -> k1T k1m, k2m -> k2T k2m};

ReplNonLin = NonLinearTransformation[k1, k2, phi, 0];
ReplNonLin=ReplNonLin/.{k1m -> k1T k1m, k2m -> k2T k2m }//Simplify[#,Assumptions->(0<k1m&&0<k2m&&0<zeta<1)]&;
ReplNonLin= ReplNonLin/.{zeta->x7}//.{k1m^2-k2m^2->(k1m+k2m)(k1m-k2m),k2m^2-k1m^2->(k1m+k2m)(k2m-k1m)};
ReplNonLin=SplitAndAssignVariables[ReplNonLin,{k1m,k2m},{x1,x2},{k1m,k2m},Jacobian->False] /. Power[arg_, pow_] :> Power[Factor[arg], pow]/.Abs[a_]:>Sqrt[a^2]//ExpandPower//Simplify//ExpandPower;
 

sectors =SplitAndAssignVariables[res,{k1m,k2m},{x1,x2},{k1m,k2m}] /.Abs[a_]:>Sqrt[a^2]//ExpandPower//Simplify;
sectors=Table[J[ReplNonLin[[i,1]]] (sectors[[i]]/.ReplNonLin[[i,2]]),{i,Length[sectors]}];(*Now apply nNonLinTrans*)

 (*Print[ReplNonLin];*)
  If[Cases[sectors,th1|ch1|ch2|ph1,-1]=!={},Message[SectorDecomposition::leftangles,DeleteDuplicates[Cases[sectors,Cos[_]|Sin[_]|Csc[_]|Tan[_],-1]]]];

(*************************************************************************************)
sectors=sectors//ExpandPower//Simplify;
(*************************************************************************************)
   sectors=HalfSplit[sectors,{x1,x2}];
(*************************************************************************************)
   sectors=SplitAndAssignVariables[sectors,{k1T,k2T},{x3,x4},{k1T,k2T}]//Flatten;
(*************************************************************************************) 
  If[simplify,
   sectors = Simplify[sectors/.sr[a_]:>sr[Factor[a]]//ExpandPower]
   ];
(*************************************************************************************) 
   
(*sectors=AppendLC3[sectors,simplify];*)

sectors =J[(1-x6)^-2]sectors/.k3T->(x6/(1-x6))/.k3m->x5//ExpandPower;

Return[sectors];
         
];
         
         


(* ::Subsection::Closed:: *)
(*AE3*)


SectorDecompositionAE3[integral_, k1_, k2_, phi_, simplify_] := Module[{
  ReplSin =GenerateReplSin[{{th1,x1},{ch1,x2},{ph1,x6},{ph2,x8}}], 
  k3 = Last[Complement[{l1,l2,l3},{k1,k2}]],
  ReplNonLin, jacnonlin, res, k10, k20, k30, sectors
  },

  (*Print[{k1,k2,phi}];*)
  (* Relevant integration variables *)
  k10 = ToExpression[ToString[k1]<>"0"];
  k20 = ToExpression[ToString[k2]<>"0"];
  k30 = ToExpression[ToString[k3]<>"0"];

  (* Put all but props to J function *)
  res = J[integral];

  (* Replace four angles by x1, x2, x6, x8 *)
  res = J[2/Sin[th1] 2/Sin[ch1] 2/Sin[ph1] 2/Sin[ph2]] res //. ReplSin;
  
  
  (*****************************************************************************
   *
   * Non-linear transformation (eliminates azimuthal angle and maps k1.k2
   * singularity into the line Cos[th1] = Cos[ch1])
   *
   ****************************************************************************)
ReplNonLin = NonLinearTransformation[ch1, th1, phi, 0]/.zeta->x7//.ReplSin;
ReplNonLin  =TriangleSplit[{ReplNonLin },{{x1,x2}},Jacobian->False]/.Power[arg_, pow_] :> Power[Factor[arg], pow]/.Abs[a_]:>Sqrt[a^2]//ExpandPower; 

(*************************************************************************************)
 sectors =TriangleSplit[{res},{{x1,x2}}]/.Power[arg_, pow_] :> Power[Factor[arg], pow]/.Abs[a_]:>sr[a^2]//ExpandPower; 
sectors=Table[J[ReplNonLin[[i,1]]] (sectors[[i]]/.ReplNonLin[[i,2]]),{i,Length[sectors]}];

(*Print[ReplNonLin];*)
 If[Cases[sectors,th1|ch1|ch2|ph1|ph2,-1]=!={},Message[SectorDecomposition::leftangles,Cases[sectors,Cos[_]|Sin[_]|Csc[_]|Tan[_],-1]]];
 
(*************************************************************************************)
 sectors =HalfSplit[sectors,{x1,x2}]/.Power[arg_, pow_] :> Power[Factor[arg], pow]/.Abs[a_]:>Sqrt[a^2]//ExpandPower; 
(* /.Abs[a_]:>Simplify[Abs[a]]/.sr[arg_]:>sr[Factor[arg]]*)
(*************************************************************************************)
 If[simplify===True,sectors=sectors//ExpandPower;
 sectors=sectors//Simplify];  
(*************************************************************************************)
sectors=SplitAndAssignVariables[sectors,{k10,k20},{x3,x4},{k10,k20}]//ExpandPower// Flatten;
(*************************************************************************************)

If[simplify===True,sectors = sectors//ExpandPower//Simplify];

(* sectors=(#)&/@sectors;*)
 sectors = sectors/.{k30 -> x5};
(*sectors=AppendAE3[sectors,simplify];*)
Return[sectors]
 ];
         


(* ::Subsection::Closed:: *)
(*LC2*)


SectorDecompositionLC2[integral_, k1_, k2_, phi_,simplify_] := Module[{
ReplSin =GenerateReplSin[{{ph1,x8}}],
  ReplNonLin, jacnonlin, res, k1m, k2m, k1T, k2T, sectors,
  k3=First[Complement[{l1,l2,l3},{k1,k2}]],k3m,k3T,variables},
  
  k1m = ToExpression[ToString[k1]<>"m"];
  k2m = ToExpression[ToString[k2]<>"m"];
  k3m = ToExpression[ToString[k3]<>"m"];
  k1T = ToExpression[ToString[k1]<>"T"];
  k2T = ToExpression[ToString[k2]<>"T"];
  k3T = ToExpression[ToString[k3]<>"T"];
  variables = list[k1m, k2m, k3m, k1T, k2T];

  (* Put all but props to J function *)
  res = J[integral];
  res= J[2/Sin[ph1]]res//.ReplSin;
  res = J[k1T k3T k2T] HeavisideTheta[1-k1m] HeavisideTheta[1-k2m] HeavisideTheta[1-k3m] res /.{k1m -> k1T k1m, k2m -> k2T k2m, k3m -> k3T k3m};
  
 ReplNonLin = NonLinearTransformation[k1, k3, phi,0]/.zeta->x7;
 ReplNonLin=ReplNonLin/.{k1m -> k1T k1m, k2m -> k2T k2m, k3m -> k3T k3m}//Simplify[#,Assumptions->(0<k1m&&0<k3m&&0<zeta<1)]&;
 ReplNonLin= ReplNonLin//.{k1m^2-k3m^2->(k1m+k3m)(k1m-k3m),k3m^2-k1m^2->(k1m+k3m)(k3m-k1m)}/.Abs[a_]:>Sqrt[a^2]//ExpandPower;
 ReplNonLin= {ReplNonLin/. {k3m->(1-x1) k1m}/.{k2m->x2/(1-x2)}, ReplNonLin /. {k1m->(1-x1) k3m}/.{k2m->x2/(1-x2)}}//ExpandPower//Simplify//ExpandPower;

 (*****************************************************************************
   *
   * Splitting along k1m = k3m (removes overlapping singularities k1m, k3m -> 0)
   * and splitting at x2>1/2 and x2<1/2 (i.e. k2m = 1 soft singularity)
   * k2m has singularity at infinity (coll.) and 0 (anti-coll.). 
   *
   ****************************************************************************)
 
   sectors = {
          (J[k1m/(1-x2)^2] res /. {k3m->(1-x1) k1m}/.{k2m->x2/(1-x2)}),
          (J[k3m/(1-x2)^2] res /. {k1m->(1-x1) k3m}/.{k2m->x2/(1-x2)})
          }/.Abs[a_]:>Sqrt[a^2]//ExpandPower//Flatten;


sectors=Table[J[ReplNonLin[[i,1]]] (sectors[[i]]/.ReplNonLin[[i,2]]),{i,Length[sectors]}];   (*Apply NonLinTrans*) 

(*Print[ReplNonLin];*)
  If[Cases[sectors,th1|ch1|ph1,-1]=!={},Message[SectorDecomposition::leftangles,Cases[sectors,Cos[_]|Sin[_]|Csc[_]|Tan[_],-1]]];
(****************************************************************************)
sectors = SplitAndAssignVariables[sectors,{k1T,k2T},{x3,x4},{k1T,k2T}]//Flatten ;
(****************************************************************************)
 
 (*Print[sectors];*)  
 If[simplify===True,sectors=sectors/.sr[a_]:>Factor[sr[a]]//ExpandPower//Simplify];
        
        
(*sectors=AppendLC2[sectors,simplify];*)
 
 
(* sectors=(HeavisideTheta[First[Cases[#,k1m|k3m,-1]]] #)&/@sectors; *)
 sectors = sectors /.{k3m->x5,k1m->x5};
 sectors = J[(1-x6)^(-2)] sectors /.{k3T->x6/(1-x6)};
(*  sectors=Join[sectors,{0,0,0,0}];*)
  Return[sectors]
];


(* ::Subsection::Closed:: *)
(*AE2*)


SectorDecompositionAE2[integral_, k1_, k2_,simplify_] := Module[{
ReplSin =GenerateReplSin[{{th1,x6},{ch1,x1},{ch2,x7},{ph1,x2},{ph2,x8}}], 
  k3 = Last[Complement[{l1,l2,l3},{k1,k2}]],
res, k10, k20, k30, sectors, variables},

(*Print[{k1,k2}];*)
  k3  = First[Fold[DeleteCases[#1,#2]&,{l1,l2,l3},{k1,k2}]];
  k10 = ToExpression[ToString[k1]<>"0"];
  k20 = ToExpression[ToString[k2]<>"0"];
  k30 = ToExpression[ToString[k3]<>"0"];

  (* Put all but props to J function *)
  res = J[integral] ;
  
(*here needs ch2 since we don't do nonlintrans*)
res = J[2/Sin[th1] 2/Sin[ch1]2/Sin[ch2] 2/Sin[ph1] 2/Sin[ph2]] res //. ReplSin;
If[Cases[res,th1|ch1|ch2|ph1|ph2,-1]=!={},Message[SectorDecomposition::leftangles,Cases[res,Cos[_]|Sin[_]|Csc[_]|Tan[_],-1]]];
(**************************************************************************************)
sectors = SplitAndAssignVariables[res,{k10,k20},{x3,x4},{k10,k20}]//Flatten; 
(**************************************************************************************)


If[simplify===True,sectors=sectors//ExpandPower//Simplify];


  
(* sectors=(#)&/@sectors;*)
 sectors = sectors/.{k30 -> x5};
          
(*sectors=AppendAE2[sectors,simplify];*)
  Return[sectors]
];


(* ::Subsection::Closed:: *)
(*LC3SR*)


SectorDecompositionLC3SR[integral_, k1_, k2_, phi_, simplify_] := Module[{

  ReplSin = GenerateReplSin[{{ph1,x4},{ph2,x8}}],
  ReplNonLin, jacnonlin, res, k1m, k2m, k30, k1T, k2T, k3T, sectors, 
  k3 = Last[Complement[{l1,l2,l3},{k1,k2}]]
  },

  (*Print[{k1,k2,phi}];*)
  (* Relevant integration variables *)
  k1m = ToExpression[ToString[k1]<>"m"];
  k2m = ToExpression[ToString[k2]<>"m"];
  k30 = ToExpression[ToString[k3]<>"0"];(*Blocked*)
  k1T = ToExpression[ToString[k1]<>"T"];
  k2T = ToExpression[ToString[k2]<>"T"];(*Blocked*)
  (*k3T = ToExpression[ToString[k3]<>"T"];*)
  
  (* Put all but props to J function *)
  res = J[integral];
  res= J[2/Sin[ph1]2/Sin[ph2]]res//.ReplSin;
  res = J[k1T k2T] HeavisideTheta[1-k1m] HeavisideTheta[1-k2m] res /.{k1m -> k1T k1m, k2m -> k2T k2m};
 
  ReplNonLin = NonLinearTransformation[k1, k2, phi, 0]/.zeta->x7;
  ReplNonLin=ReplNonLin/.{k1m -> k1T k1m, k2m -> k2T k2m }//Simplify[#,Assumptions->(0<k1m&&0<k2m&&0<zeta<1)]&;
  ReplNonLin= ReplNonLin//.{Abs[k1m^2-k2m^2]->(k1m+k2m)Abs[(k1m-k2m)],Abs[k2m^2-k1m^2]->(k1m+k2m)Abs[(k2m-k1m)]};

  ReplNonLin= SplitAndAssignVariables[ReplNonLin,{k2m,k1m},{x2,x1},{k1m,k2m},Jacobian->False]
    /. Power[arg_, pow_] :> Power[Factor[arg], pow]/.Abs[a_]:>Sqrt[a^2]//ExpandPower//Simplify//ExpandPower;
  
  (*************************************************************************************************************)
    sectors = SplitAndAssignVariables[res,{k2m,k1m},{x2,x1},{k1m,k2m}]
    /. Power[arg_, pow_] :> Power[Factor[arg], pow]/.Abs[a_]:>Sqrt[a^2]//ExpandPower;
   
sectors=Table[J[ReplNonLin[[i,1]]] (sectors[[i]]/.ReplNonLin[[i,2]]),{i,Length[sectors]}];   (*Apply NonLinTrans*) 

 If[Cases[sectors,th1|ch1|ch2|ph1,-1]=!={},Message[SectorDecomposition::leftangles,Cases[sectors,Cos[_]|Sin[_]|Csc[_]|Tan[_],-1]]];
(* Print[ReplNonLin];*)

 If[simplify===True, sectors = Simplify[sectors//ExpandPower]];
 (*************************************************************************************************************)
 sectors=HalfSplit[sectors,{x2,x1}];

 (*************************************************************************************************************)
(*   sectors = {
       J[x4]  sectors/.k1T->x4 x3,
       J[y3^-2 k1T]  sectors/.x4->x4 k1T/.k1T->x3/y3
       
  }//Flatten; *)
 (* Print[sectors];*)
 sectors =J[(1-x3)^-2] sectors/.k1T->x3/(1-x3);
 sectors = {
       J[x4]  sectors /.{x3->x4 x3(*, y3->y4+x4 y3*)},
       J[x3]  sectors /.{x4->x4 x3(*, y4->y3+x3 y4*)}
  }//Flatten;
       
  If[simplify===True, sectors = Simplify[sectors//ExpandPower]];

  (*sectors=AppendLC3SR[sectors,simplify];
       
  sectors=(#)&/@sectors;*)
  sectors = sectors/.{k30 -> x5};
  sectors =  J[(1-x6)^(-2)]sectors/.{k2T -> x6/(1-x6)};
  Return[sectors]
];


(* ::Subsection::Closed:: *)
(*AE3SH*)


SectorDecompositionAE3SH[integral_, k1_, k2_, phi_, simplify_] := Module[{
  ReplSin =GenerateReplSin[{{th1,x1},{ch1,x2},{ph1,x8}}], 
  k3 = Last[Complement[{l1,l2,l3},{k1,k2}]],
  ReplNonLin, jacnonlin, res, k10, k20, k30, sectors,k3m,k3T
  },

  (*Print[{k1,k2,phi}];*)
  (* Relevant integration variables *)
k10 = ToExpression[ToString[k1]<>"0"];
k20 = ToExpression[ToString[k2]<>"0"];
k3m= ToExpression[ToString[k3]<>"m"];
k3T= ToExpression[ToString[k3]<>"T"];

  (* Put all but props to J function *)
  res = J[integral];

  (* Replace four angles by x1, x2, x6*)
  res = J[2/Sin[th1] 2/Sin[ch1] 2/Sin[ph1] ] res //. ReplSin;
  

ReplNonLin =NonLinearTransformation[ch1, th1, phi,0]/.zeta->x7//.ReplSin//Simplify;
ReplNonLin =TriangleSplit[{ReplNonLin},{{x1,x2}},Jacobian->False]/.Power[arg_, pow_] :> Power[Factor[arg], pow]/.Abs[a_]:>Sqrt[a^2]//ExpandPower//Simplify//ExpandPower; 
 
  
(*****************************************************************************)
sectors=TriangleSplit[{res},{{x1,x2}}]/.Power[arg_, pow_] :> Power[Factor[arg], pow]/.Abs[a_]:>Sqrt[a^2]//ExpandPower; 
sectors=Table[J[ReplNonLin[[i,1]]] (sectors[[i]]/.ReplNonLin[[i,2]]),{i,Length[sectors]}];   (*Apply NonLinTrans*) 

 (*Print[ReplNonLin];*)

 If[Cases[sectors,th1|ch1|ch2|ph1,-1]=!={},Message[SectorDecomposition::leftangles,Cases[sectors,Cos[_]|Sin[_]|Csc[_]|Tan[_],-1]]];
 
(*****************************************************************************)
    sectors = HalfSplit[sectors,{x1,x2}]/.Power[arg_, pow_] :> Power[Factor[arg], pow]/.Abs[a_]:>Sqrt[a^2]//ExpandPower;
   
  (*****************************************************************************)
   If[simplify===True,sectors=sectors//ExpandPower;
 sectors=sectors//Simplify];  
(*****************************************************************************)
sectors=SplitAndAssignVariables[sectors,{k10,k3m},{x3,x4},{k10,k3m}]//ExpandPower// Flatten;

(*****************************************************************************)
If[simplify===True,sectors = sectors//ExpandPower//Simplify];

(*sectors=AppendAE3SH[sectors,simplify];*)

  (*sectors=( #)&/@sectors;*)
  sectors = sectors/.{k20 -> x5};
sectors=J[(1-x6)^-2]sectors/.{k3T->x6/(1-x6)};
  Return[sectors];  
];


(* ::Subsection::Closed:: *)
(*N1N2*)


SectorDecompositionN1N2[integral_, k1_, k2_,  simplify_] := Module[{

  ReplSin = GenerateReplSin[{{ph1,x6},{ph2,x8},{ch1,x1},{ch2,x7}}],
   res, k10, k2m, k30, k2T, sectors, 
  k3 = Last[Complement[{l1,l2,l3},{k1,k2}]]
  },

  (* Relevant integration variables *)
  k10= ToExpression[ToString[k1]<>"0"];
  k2m = ToExpression[ToString[k2]<>"m"];
  k30 = ToExpression[ToString[k3]<>"0"];(*Blocked*)
  k2T = ToExpression[ToString[k2]<>"T"];
  (*k3T = ToExpression[ToString[k3]<>"T"];*)
  
  (* Put all but props to J function *)
  res = J[integral];
  res= J[2/Sin[ph1]2/Sin[ph2]2/Sin[ch1]2/Sin[ch2]]res//.ReplSin;

 If[Cases[res,th1|ch1|ch2|ph1|ph2,-1]=!={},Message[SectorDecomposition::leftangles,Cases[sectors,Cos[_]|Sin[_]|Csc[_]|Tan[_],-1]]];
res = J[ k2T] HeavisideTheta[1-k2m] res /.{ k2m -> k2T k2m};
res=J[(1-x2)^(-2)]res/.k2m->x2/(1-x2);

sectors=SplitAndAssignVariables[{res},{k10,k2T},{x3,x4},{k10,k2T}]//ExpandPower//Flatten;
 If[simplify===True,
 sectors=sectors//ExpandPower(*//.Replsr*)//Simplify];
 
(*sectors=AppendN1N2[sectors,simplify];

  sectors=(#)&/@sectors;*)
  sectors = sectors/.{k30 -> x5};

  Return[sectors]
];


(* ::Subsection::Closed:: *)
(*SecDec*)


If[numberofparticles===3,
SecDec[exp_,info_,simplify_:True]:=Module[{print="none",secdec,phi},
Print[info];
If[Length[info[[3]]]==3,
Print["123"];
secdec=SectorDecomposition123[exp,info[[3,1]],info[[3,2]],ph2,simplify];
];
If[Length[info[[3]]]==2,
If[Length[info[[1]]]==2&&Length[info[[2]]]==0,
Print["LC3"];
secdec=SectorDecompositionLC3[exp,info[[3,1]],info[[3,2]],ch1,simplify];
];
If[Length[info[[1]]]==2&&Length[info[[2]]]==1,
Print["LC3SR"];
secdec=SectorDecompositionLC3SR[exp,info[[3,1]],info[[3,2]],ch1,simplify];

];
If[Length[info[[2]]]==2&&Length[info[[1]]]==0,
Print["AE3"];
secdec=SectorDecompositionAE3[exp,info[[3,1]],info[[3,2]],ch2,simplify];
];
If[Length[info[[2]]]==2&&Length[info[[1]]]==1,
Print["AE3SH"];
secdec=SectorDecompositionAE3SH[exp,info[[3,1]],info[[3,2]],ch2,simplify];
];
If[Length[info[[1]]]==1&&Length[info[[2]]]==0,
Print["LC2"];
secdec=SectorDecompositionLC2[exp,info[[3,1]],First[Complement[info[[1]],info[[3]]]],ch1,simplify];
];
If[Length[info[[1]]]==0&&Length[info[[2]]]==1,
Print["AE2"];
secdec=SectorDecompositionAE2[exp,info[[3,1]],First[Complement[info[[2]],info[[3]]]],simplify];
];
];
If[Length[info[[3]]]==1,Print["Input Error"]];
If[Length[info[[3]]]==0,
Print["N1N2"];
secdec=SectorDecompositionN1N2[exp,info[[2,1]],info[[1,1]],simplify]
];
(*Return[secdec];*)
If[SplitPattern=!=<||>,
secdec=Fold[TriangleSplit[#1,#2]&,secdec,SplitPattern[types[info]]]
];
Return[SDFinalProcessing[secdec]];


];
]


SecDec2[decomposed_,appearvars_]:=Module[{me0,replcos,cosines,replother,other,decomposedrepl,decomposedjaco},
me0=Map[Cases[#,ME0[a__]:>a,-1]&,decomposed];
replcos=Pick[#,Map[MatchQ[#,Sin[_]|Cos[_]]&,appearvars],True]&/@me0;
cosines=Pick[appearvars,Map[MatchQ[#,Sin[_]|Cos[_]]&,appearvars],True];
replcos=Flatten[MapThread[{#1->#2,ReplaceAll[#1,{Sin->Sec,Cos->Csc}]->1/#2}&,{cosines,#}]]&/@replcos;
replcos=Map[Join[#,{Tan[a_]:>Sin[a]/Cos[a],Cot[a_]:>Cos[a]/Sin[a],Sin[a_/2]:>1/Sqrt[2]Sqrt[(1-Cos[a])],Cos[a_/2]:>1/Sqrt[2]Sqrt[(1+Cos[a])]}]&,replcos];
replother=Pick[#,Map[MatchQ[#,Sin[_]|Cos[_]]&,appearvars],False]&/@me0;
other=Pick[appearvars,Map[MatchQ[#,Sin[_]|Cos[_]]&,appearvars],False];
replother=Flatten[MapThread[#1->#2&,{other,#}]]&/@replother;
decomposedrepl=MapThread[Union[#1,#2]&,{replcos,replother}];
decomposedjaco=Map[#/.ME0[a__]:>1&,decomposed];
Return[{decomposedjaco,decomposedrepl}]
];


(* ::Section::Closed:: *)
(*SecDec1L*)


(* ::Subsection::Closed:: *)
(*12*)


SectorDecomposition12[integral_,k1_,k2_]:=Module[{secdec,replsin,k10,k20},
secdec=J[integral];
 k10 = ToExpression[ToString[k1]<>"0"];
k20 = ToExpression[ToString[k2]<>"0"];
replsin=GenerateReplSin[{{th1,x3},{ch1,x2},{ch2,x4}}];
secdec={J[8/(Sin[th1]Sin[ch1]Sin[ch2])]secdec/.replsin};
secdec=J[(1)/(1-x1)^2]secdec/.k10->x1/(1-x1);
secdec=secdec HeavisideTheta[k20]/.k20->x5;
secdec=secdec //Simplify//ExpandPower;
Return[secdec]]



(* ::Subsection::Closed:: *)
(*AE1S*)


(* ::Input:: *)
(**)


SectorDecompositionAE1S[integral_,k1_,k2_]:=Module[{secdec,replsin,k10,k20},
secdec=J[integral];
 k10 = ToExpression[ToString[k1]<>"0"];
k20 = ToExpression[ToString[k2]<>"0"];
replsin=GenerateReplSin[{{th1,x2},{ch1,x3},{ch2,x4}}];
secdec={J[8/(Sin[th1]Sin[ch1]Sin[ch2])]secdec/.replsin};
secdec=J[(1)/(1-x1)^2]secdec/.k10->x1/(1-x1);
secdec=secdec HeavisideTheta[k20]/.k20->x5;
secdec=secdec //Simplify//ExpandPower;
Return[secdec]]



(* ::Subsection::Closed:: *)
(*AE1HR*)


SectorDecompositionAE1HR[integral_,k1_,k2_]:=Module[{secdec,replsin,k10,k2m,k2T},
secdec=J[integral];

k10 = ToExpression[ToString[k1]<>"0"];
k2m = ToExpression[ToString[k2]<>"m"];
k2T = ToExpression[ToString[k2]<>"T"];
replsin=GenerateReplSin[{{ch1,x2},{ch2,x3}}];
secdec={J[4/(Sin[ch1]Sin[ch2])]secdec//.replsin};
secdec=J[k2T] secdec HeavisideTheta[1-k2m]/.k2m->k2m k2T;
secdec=J[1/(1-x1)^2]secdec//.k2m->x1/(1-x1);
secdec=J[1/(1-x4)^2]secdec//.k2T->x4/(1-x4);
secdec=secdec HeavisideTheta[k10]//.k10->x5;

secdec=secdec //Simplify//ExpandPower;
Return[secdec]]



(* ::Subsection::Closed:: *)
(*LC1S*)


SectorDecompositionLC1S[integral_,k1_,k2_]:=Module[{secdec,replsin,k1m,k1T,k2m,k2T},
secdec=J[integral];
 k1m = ToExpression[ToString[k1]<>"m"];
 k1T = ToExpression[ToString[k1]<>"T"];
k2m = ToExpression[ToString[k2]<>"m"];
k2T = ToExpression[ToString[k2]<>"T"];

replsin=GenerateReplSin[{{ch1,x3}}];
secdec={J[2/(Sin[ch1])]secdec/.replsin};
secdec=J[k1T] secdec HeavisideTheta[1-k1m]/.k1m->k1m k1T;

secdec=J[1/(1-x1)^2]secdec/.k1m->x1/(1-x1);
secdec=J[1/(1-x2)^2]secdec/.k1T->x2/(1-x2);
secdec=J[1/(1-x4)^2]secdec/.k2T->x4/(1-x4);

secdec=secdec HeavisideTheta[k2m]//.k2m->x5;
secdec=secdec //Simplify//ExpandPower;
Return[secdec]]



(* ::Subsection::Closed:: *)
(*SecDec*)


If[numberofparticles===2,
SecDec[integral_,inputraw_]:=Module[{secdec},
Print[types[inputraw]];

If[MemberQ[{"SectorDecomposition12","SectorDecompositionAE1S","SectorDecompositionLC1S"},types[inputraw]],
secdec=Apply[ToExpression[types[inputraw]],Join[{integral},inputraw[[4]]]];

,
secdec=Apply[ToExpression[types[inputraw]],Join[{integral},inputraw[[2]],inputraw[[1]]]];

];




If[SplitPattern=!=<||>,
secdec=Fold[TriangleSplit[#1,#2]&,secdec,SplitPattern[types[inputraw]]]
];
Return[SDFinalProcessing[secdec]];
];
];


(* ::Section::Closed:: *)
(*SecDec1*)


If[numberofparticles===1,
SecDec[integral_,inputraw_]:=Module[{secdec},
Print[types[inputraw]];

secdec=nloSecDec[integral,First[inputraw[[4]]]];




If[SplitPattern=!=<||>,
secdec=Fold[TriangleSplit[#1,#2]&,secdec,SplitPattern[types[inputraw]]]
];
Return[SDFinalProcessing[secdec]];
];
];



nloSecDec[integral_,k1_]:=Module[{k10,res,replsin},
k10=ToExpression[ToString[k1]<>"0"];
res = J[integral];

replsin=GenerateReplSin[{{th1,x1}}];
res=2/Sin[th1] res/.replsin;
res=J[1/(1-x5)^2 ]res/.{l10->x5/(1-x5)}//Simplify;
Return[{res}]
];


(* ::Section::Closed:: *)
(*End*)


(* ::Input::Initialization:: *)
If[VerboseFunctions==2&&packageread=!=True,
Print["********GenerateReplSin.********"];
input=HoldForm[GenerateReplSin[{{th1,x1}}]];
Print["e.g.  ",Style[ToString[input],Darker[Green]]];
Print[input//ReleaseHold];
Print["******Other Replacements.******"];
Print[Style[ToString[HoldForm[Reply]],Darker[Green]]];
Print[Reply//ReleaseHold];
Print[Style[ToString[HoldForm[Replx]],Darker[Green]]];
Print[Replx//ReleaseHold];
Print[Style[ToString[HoldForm[Recov]],Darker[Green]]];
Print[Recov//ReleaseHold];
Print["*******************************"];
packageread=True;
];


packageread=True;


End[];

EndPackage[];
